name: Generate Assignment Feedback

# Trigger on push to any branch to detect assignment updates
on:
  push:
    paths:
      - '20-assignments/**/workspace/**'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  detect-and-generate-feedback:
    name: Generate Feedback for Updated Assignments
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history to detect changes
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect changed assignments
        id: detect
        run: |
          # For push events, compare with previous commit
          if [ -z "${{ github.event.before }}" ] || [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
            # First commit on branch or workflow_dispatch
            if git rev-parse HEAD^ >/dev/null 2>&1; then
              BASE_REF="HEAD^"
            else
              BASE_REF="${{ github.sha }}"
            fi
          else
            BASE_REF="${{ github.event.before }}"
          fi
          HEAD_REF="${{ github.sha }}"
          
          echo "Comparing $BASE_REF...$HEAD_REF"
          
          # Get changed files in assignments workspace folders
          CHANGED_FILES=$(git diff --name-only $BASE_REF $HEAD_REF | grep '^20-assignments/.*/workspace/' || true)
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No assignment changes detected"
            echo "assignments=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Extract unique assignment folders
          ASSIGNMENTS=$(echo "$CHANGED_FILES" | sed 's|20-assignments/\([^/]*\)/.*|\1|' | sort -u | tr '\n' ' ')
          
          echo "Changed assignments: $ASSIGNMENTS"
          echo "assignments=$ASSIGNMENTS" >> $GITHUB_OUTPUT

      - name: Configure Git
        if: steps.detect.outputs.assignments != ''
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Generate feedback for all assignments
        if: steps.detect.outputs.assignments != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COPILOT_GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
          ASSIGNMENTS: ${{ steps.detect.outputs.assignments }}
        run: |
          # Install GitHub Copilot CLI if not available
          command -v copilot >/dev/null 2>&1 || curl -fsSL https://gh.io/copilot-install | sudo bash

          # Configure git with autostash and ignore rebase warnings
          git config pull.rebase true
          git config rebase.autoStash true
          git config advice.skippedCherryPicks false
          
          for ASSIGNMENT in $ASSIGNMENTS; do
            if [ -z "$ASSIGNMENT" ]; then
              continue
            fi
            
            ASSIGNMENT_PATH="20-assignments/$ASSIGNMENT"
            README_PATH="$ASSIGNMENT_PATH/README.md"
            WORKSPACE_PATH="$ASSIGNMENT_PATH/workspace"
            FEEDBACK_PATH="$ASSIGNMENT_PATH/FEEDBACK.md"
            
            if [ ! -f "$README_PATH" ]; then
              echo "âš ï¸ README not found for $ASSIGNMENT, skipping..."
              continue
            fi
            
            if [ ! -d "$WORKSPACE_PATH" ]; then
              echo "âš ï¸ Workspace not found for $ASSIGNMENT, skipping..."
              continue
            fi

            # Pull before processing each assignment
            echo "ðŸ”„ Pulling latest changes before processing $ASSIGNMENT..."
            git pull origin main || echo "Pull completed with warnings (ignored)"
            
            echo "ðŸ“ Generating feedback for: $ASSIGNMENT"
            
            PROMPT_FILE=".github/prompts/GetFeedback.prompt.md"
            PROMPT_CONTENT="$(cat "$PROMPT_FILE")"
            PROMPT="$(printf '%s\n\nAssignment path: %s\nUse the Feedback agent and update FEEDBACK.md in that assignment folder.' "$PROMPT_CONTENT" "$ASSIGNMENT_PATH")"

            # Retry logic for feedback generation
            MAX_RETRIES=3
            RETRY_COUNT=0
            SUCCESS=false

            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if copilot \
                --agent=Feedback \
                --prompt "$PROMPT" \
                --allow-all-tools \
                --allow-all-paths; then
                SUCCESS=true
                echo "âœ… Generated feedback for $ASSIGNMENT"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "âš ï¸ Feedback generation failed for $ASSIGNMENT (attempt $RETRY_COUNT/$MAX_RETRIES). Retrying in 5 seconds..."
                  sleep 5
                else
                  echo "âŒ Failed to generate feedback for $ASSIGNMENT after $MAX_RETRIES attempts. Skipping..."
                fi
              fi
            done

            if [ "$SUCCESS" = false ]; then
              continue
            fi

            # Pull, commit and push after each feedback update
            if git status --porcelain | grep -q "FEEDBACK.md"; then
              # Retry logic for commit and push
              MAX_PUSH_RETRIES=3
              PUSH_RETRY_COUNT=0
              PUSH_SUCCESS=false

              while [ $PUSH_RETRY_COUNT -lt $MAX_PUSH_RETRIES ]; do
                echo "ðŸ”„ Pulling latest changes before committing $ASSIGNMENT..."
                if git pull origin main || echo "Pull completed with warnings (ignored)"; then
                  # Check if FEEDBACK.md exists and has changes that can be staged
                  if [ -f "$ASSIGNMENT_PATH/FEEDBACK.md" ] && git status --porcelain "$ASSIGNMENT_PATH/FEEDBACK.md" | grep -q "FEEDBACK.md"; then
                    git add "$ASSIGNMENT_PATH/FEEDBACK.md"
                  else
                    echo "âš ï¸ FEEDBACK.md not found or no changes to stage at $ASSIGNMENT_PATH, skipping commit..."
                    break
                  fi
                  
                  if git commit -m "chore: update feedback for $ASSIGNMENT" || echo "Nothing to commit"; then
                    echo "â¬†ï¸ Pushing feedback for $ASSIGNMENT..."
                    
                    if git push origin main; then
                      PUSH_SUCCESS=true
                      echo "âœ… Successfully pushed feedback for $ASSIGNMENT"
                      break
                    fi
                  fi
                fi
                
                PUSH_RETRY_COUNT=$((PUSH_RETRY_COUNT + 1))
                if [ $PUSH_RETRY_COUNT -lt $MAX_PUSH_RETRIES ]; then
                  echo "âš ï¸ Push failed for $ASSIGNMENT (attempt $PUSH_RETRY_COUNT/$MAX_PUSH_RETRIES). Retrying in 3 seconds..."
                  sleep 3
                else
                  echo "âŒ Failed to push feedback for $ASSIGNMENT after $MAX_PUSH_RETRIES attempts"
                fi
              done

              if [ "$PUSH_SUCCESS" = false ]; then
                echo "âš ï¸ Feedback was generated but could not be pushed for $ASSIGNMENT"
              fi
            else
              echo "â„¹ï¸ No feedback changes detected for $ASSIGNMENT"
            fi
          done

      - name: Summary
        if: always()
        run: |
          echo "### Feedback Generation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          ASSIGNMENTS="${{ steps.detect.outputs.assignments }}"
          
          if [ -z "$ASSIGNMENTS" ]; then
            echo "âœ… No assignment changes detected" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“ Assignments requiring feedback:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            for ASSIGNMENT in $ASSIGNMENTS; do
              if [ -n "$ASSIGNMENT" ]; then
                echo "- \`$ASSIGNMENT\`" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Feedback files were generated via GitHub Copilot CLI." >> $GITHUB_STEP_SUMMARY
          fi
